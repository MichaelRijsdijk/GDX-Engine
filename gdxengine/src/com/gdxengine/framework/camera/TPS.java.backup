package com.akemisan.framework.camera;

import com.akemisan.framework.helper.Utils;
import com.badlogic.gdx.graphics.PerspectiveCamera;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Matrix4;
import com.badlogic.gdx.math.Vector3;

public class ThirdPersonCamera extends PerspectiveCamera {

	 public Vector3 AvatarHeadOffset;
     public Vector3 TargetOffset;

     float lastY;float lastX;float lastZ;
     Vector3 lastPosition;
     float time = 0f;
     float chaseSpeed = 2f;

     public ThirdPersonCamera(float fieldOfView, float viewportWidth, float viewportHeight)
     {
    	 super(fieldOfView, viewportWidth, viewportHeight);
         AvatarHeadOffset = new Vector3(0, 3, -5);
         TargetOffset = new Vector3(0, 0, 3);
         view.idt();
         
         lastPosition = new Vector3(position);
     }

     public void Update(float x,float y,float z, Vector3 vectorUp, Vector3 position, float elapsedTime)
     {
    	 
         boolean needResetTie = false;
         time += elapsedTime;
         if (y != lastY)
         {
             float interpolatedSpeed = MathUtils.clamp(chaseSpeed * elapsedTime, 0.0f, 1.0f);
             y = Utils.Lerp(lastY, y, interpolatedSpeed);
             needResetTie = false;
         }
         else
         {
             needResetTie = true;
         }
         if (x != lastX)
         {
             float interpolatedSpeed = MathUtils.clamp(chaseSpeed * elapsedTime, 0.0f, 1.0f);
             x = Utils.Lerp(lastX, x, interpolatedSpeed);
             needResetTie = false;
         }
         else
         {
             needResetTie = true;
         }
         if (z != lastZ)
         {
             float interpolatedSpeed = MathUtils.clamp(chaseSpeed * elapsedTime, 0.0f, 1.0f);
             z = Utils.Lerp(lastZ, z, interpolatedSpeed);
             needResetTie = false;
         }
         else
         {
             needResetTie = true;
         }
         if (lastPosition != position)
         {
             float interpolatedSpeed = MathUtils.clamp(chaseSpeed * elapsedTime, 0.0f, 1.0f);
             this.position.set(Utils.Lerp(lastPosition, position, interpolatedSpeed));
         }
         else
         {
             needResetTie = true;
         }
         if (needResetTie)
         {
             time = 0f;
         }
         Matrix4 rotationMatrix = new Matrix4();
         rotationMatrix = Utils.createRotate(x,y,z,rotationMatrix);
         Vector3 transformedheadOffset = Utils.Transform(AvatarHeadOffset, rotationMatrix);
         Vector3 transformedReference = Utils.Transform(TargetOffset, rotationMatrix);

         Vector3 cameraPosition = Utils.addVector(this.position, transformedheadOffset);
         Vector3 cameraTarget = Utils.addVector(this.position , transformedReference);
         
         vectorUp  = Utils.Transform(vectorUp, rotationMatrix);

         lastY = y;
         lastPosition = this.position;
         
         view.setToLookAt(cameraPosition, cameraTarget, vectorUp);
         float aspect = viewportWidth / viewportHeight;
 		projection.setToProjection(Math.abs(near), Math.abs(far), fieldOfView, aspect);
 		combined.set(projection);
		Matrix4.mul(combined.val, view.val);

		invProjectionView.set(combined);
		Matrix4.inv(invProjectionView.val);
		frustum.update(invProjectionView);

     }
 }
